import 'dart:math' as math;

import 'package:flutter/cupertino.dart';

const double _screenEdgePadding = 10.0;
const double _popoverVerticalGap = 8.0;

class AppPopoverMenuItem<T> {
  final T value;
  final IconData icon;
  final String label;
  final bool enabled;
  final bool isDestructiveAction;

  const AppPopoverMenuItem({
    required this.value,
    required this.icon,
    required this.label,
    this.enabled = true,
    this.isDestructiveAction = false,
  });
}

class _PopoverAnchor {
  final Rect rect;
  final Size overlaySize;
  final EdgeInsets safePadding;

  const _PopoverAnchor({
    required this.rect,
    required this.overlaySize,
    required this.safePadding,
  });
}

class _PopoverPosition {
  final double left;
  final double top;

  const _PopoverPosition({
    required this.left,
    required this.top,
  });
}

class _PopoverLayout {
  final _PopoverPosition position;
  final double maxHeight;

  const _PopoverLayout({
    required this.position,
    required this.maxHeight,
  });
}

Future<T?> showAppPopoverMenu<T>({
  required BuildContext context,
  required GlobalKey anchorKey,
  required List<AppPopoverMenuItem<T>> items,
  double width = 196,
  double itemHeight = 44,
  double radius = 12,
  double verticalPadding = 6,
}) {
  assert(items.isNotEmpty, 'items should not be empty');
  final anchor = _resolveAnchor(context: context, anchorKey: anchorKey);
  final estimatedHeight = _estimateHeight(
    itemCount: items.length,
    itemHeight: itemHeight,
    verticalPadding: verticalPadding,
  );
  final layout = _resolveLayout(
    anchor: anchor,
    width: width,
    estimatedHeight: estimatedHeight,
  );
  final barrierLabel = CupertinoLocalizations.of(context).modalBarrierDismissLabel;
  return showGeneralDialog<T>(
    context: context,
    useRootNavigator: true,
    barrierDismissible: true,
    barrierLabel: barrierLabel,
    barrierColor: CupertinoColors.black.withValues(alpha: 0.06),
    pageBuilder: (popupContext, __, ___) {
      final labelColor = CupertinoColors.label.resolveFrom(popupContext);
      final iconColor = CupertinoColors.secondaryLabel.resolveFrom(popupContext);
      final destructiveColor = CupertinoColors.systemRed.resolveFrom(popupContext);
      final bg = CupertinoColors.systemBackground.resolveFrom(popupContext);

      return GestureDetector(
        behavior: HitTestBehavior.opaque,
        onTap: () => Navigator.of(popupContext).pop(),
        child: Stack(
          children: [
            Positioned(
              left: layout.position.left,
              top: layout.position.top,
              width: width,
              child: _PopoverSurface(
                backgroundColor: bg,
                radius: radius,
                child: ConstrainedBox(
                  constraints: BoxConstraints(maxHeight: layout.maxHeight),
                  child: Padding(
                    padding: EdgeInsets.symmetric(vertical: verticalPadding),
                    child: ListView.builder(
                      padding: EdgeInsets.zero,
                      shrinkWrap: true,
                      physics: const BouncingScrollPhysics(),
                      itemCount: items.length,
                      itemBuilder: (context, index) {
                        final item = items[index];
                        return _PopoverMenuRow(
                          height: itemHeight,
                          icon: item.icon,
                          label: item.label,
                          enabled: item.enabled,
                          iconColor: item.isDestructiveAction
                              ? destructiveColor
                              : iconColor,
                          textColor: item.isDestructiveAction
                              ? destructiveColor
                              : labelColor,
                          onTap: item.enabled
                              ? () => Navigator.of(popupContext).pop(item.value)
                              : null,
                        );
                      },
                    ),
                  ),
                ),
              ),
            ),
          ],
        ),
      );
    },
  );
}

_PopoverAnchor _resolveAnchor({
  required BuildContext context,
  required GlobalKey anchorKey,
}) {
  final anchorContext = anchorKey.currentContext;
  if (anchorContext == null) {
    throw FlutterError('showAppPopoverMenu: anchorKey has no currentContext');
  }
  final renderBox = anchorContext.findRenderObject();
  if (renderBox is! RenderBox || !renderBox.hasSize) {
    throw FlutterError('showAppPopoverMenu: anchorKey renderBox not ready');
  }
  final overlayBox =
      Overlay.of(context, rootOverlay: true).context.findRenderObject() as RenderBox;
  final anchorOffset = renderBox.localToGlobal(Offset.zero);
  return _PopoverAnchor(
    rect: anchorOffset & renderBox.size,
    overlaySize: overlayBox.size,
    safePadding: MediaQuery.of(context).padding,
  );
}

double _estimateHeight({
  required int itemCount,
  required double itemHeight,
  required double verticalPadding,
}) {
  return verticalPadding * 2 + itemHeight * math.max(1, itemCount);
}

_PopoverLayout _resolveLayout({
  required _PopoverAnchor anchor,
  required double width,
  required double estimatedHeight,
}) {
  final overlaySize = anchor.overlaySize;
  final maxLeft = overlaySize.width - width - _screenEdgePadding;
  final desiredLeft = anchor.rect.right - width;
  final left = desiredLeft.clamp(_screenEdgePadding, maxLeft).toDouble();

  final safeTop = math.max(anchor.safePadding.top, _screenEdgePadding);
  final safeBottom = math.max(anchor.safePadding.bottom, _screenEdgePadding);
  final belowTop = anchor.rect.bottom + _popoverVerticalGap;
  final availableBelow = overlaySize.height - safeBottom - belowTop;
  final availableAbove = anchor.rect.top - safeTop - _popoverVerticalGap;
  final canFitBelow = estimatedHeight <= availableBelow;
  final canFitAbove = estimatedHeight <= availableAbove;
  final showBelow = canFitBelow || (!canFitAbove && availableBelow >= availableAbove);

  final maxHeight =
      math.max(0, showBelow ? availableBelow : availableAbove).toDouble();
  final resolvedHeight = math.min(estimatedHeight, maxHeight);
  final rawTop = showBelow
      ? belowTop
      : anchor.rect.top - resolvedHeight - _popoverVerticalGap;
  final maxTop = overlaySize.height - safeBottom - resolvedHeight;
  final top = rawTop.clamp(safeTop, math.max(safeTop, maxTop)).toDouble();

  return _PopoverLayout(
    position: _PopoverPosition(left: left, top: top),
    maxHeight: maxHeight,
  );
}

class _PopoverSurface extends StatelessWidget {
  final Widget child;
  final Color backgroundColor;
  final double radius;

  const _PopoverSurface({
    required this.child,
    required this.backgroundColor,
    required this.radius,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      decoration: BoxDecoration(
        color: backgroundColor,
        borderRadius: BorderRadius.circular(radius),
        boxShadow: const [
          BoxShadow(
            color: Color(0x1F000000),
            blurRadius: 18,
            offset: Offset(0, 10),
          ),
        ],
      ),
      clipBehavior: Clip.antiAlias,
      child: child,
    );
  }
}

class _PopoverMenuRow extends StatelessWidget {
  final double height;
  final IconData icon;
  final String label;
  final bool enabled;
  final Color iconColor;
  final Color textColor;
  final VoidCallback? onTap;

  const _PopoverMenuRow({
    required this.height,
    required this.icon,
    required this.label,
    required this.enabled,
    required this.iconColor,
    required this.textColor,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    return Opacity(
      opacity: enabled ? 1 : 0.45,
      child: CupertinoButton(
        padding: EdgeInsets.zero,
        minimumSize: Size.zero,
        onPressed: onTap,
        child: SizedBox(
          height: height,
          child: Padding(
            padding: const EdgeInsets.symmetric(horizontal: 12),
            child: Row(
              children: [
                Icon(icon, size: 18, color: iconColor),
                const SizedBox(width: 10),
                Expanded(
                  child: Text(
                    label,
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                    style: TextStyle(
                      color: textColor,
                      fontSize: 15,
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}
